# 微服务设计
## week8 用户grpc服务
1. 同步用户表
```go
type BaseModel struct {
	ID        int32     `gorm:"primary_key"`
	CreatedAt time.Time `gorm:"column:add_time"`
	UpdatedAt time.Time `gorm:"column:update_time"`
	DeletedAt gorm.DeletedAt
	IsDelete  bool
}

type User struct {
	BaseModel
	Mobile   string     `gorm:"index:idx_mobile;unique;type:varchar(11);not null comment '11位电话号码'"`
	Password string     `gorm:"type:varchar(100);not null comment '密码，100位以内'"`
	NickName string     `gorm:"type:varchar(20) comment '昵称，20位以内'"`
	Birthday *time.Time `gorm:"type:datetime comment '出生日期'"`
	Gender   string     `gorm:"column:gender;default:male;type:varchar(6) comment 'female表示女，male表示男'"`
	Role     int        `gorm:"column:role;default:1;type:int comment '1表示普通用户，2表示管理员'"`
}
```
2. md5加密（信息摘要算法，密码不可反解）
    - 压缩性：任意长度的数据，计算出来的md5值都是一样长
    - 容易计算
    - 抗修改性：对于任意长度的数据，对数据进行任何修改，哪怕 modifications 是 ONE BIT， MD5 值也会改变
    - 抗碰撞性：对于任意长度的数据， MD5 函数的计算结果很难出现两个数据结果相同
    - 不可反解
   
     但是md5会被暴力破解（彩虹表）
    - md5盐值加密： 随机字符串+用户密码生成新的密码值 GitHub go-password-encoder
    - password存储： ”$算法$salt$encodedpwd"


3. 定义proto接口
```protobuf
syntax="proto3";
import "google/protobuf/empty.proto";
option go_package = "./;proto";

service User{
  rpc GetUserList(PageInfo) returns (UserListResponse); //用户列表
  rpc GetUserByMobile(MobileRequest) returns (UserInfoResponse);
  rpc GetUserById(IdRequest) returns (UserInfoResponse);
  rpc CreateUser(CreateUserInfo) returns (UserInfoResponse);
  rpc UpdateUser(UpdateUserInfo) returns (google.protobuf.Empty);
  rpc CheckPassword(PasswordCheckInfo) returns (CheckResponse);
}

message PageInfo{
  uint32 pn = 1;
  uint32 pSize = 2;
}

message MobileRequest{
  string mobile = 1;
}

message IdRequest{
  int32 id = 1;
}

message CreateUserInfo{
  string nickName = 1;
  string password = 2;
  string mobile = 3;
}

message UpdateUserInfo{
  int32 id = 1;
  string nickName = 2;
  string gender = 3;
  uint64 birthday = 4;
}

message PasswordCheckInfo{
  string password = 1;
  string encryptedPassword = 2;
}

message UserInfoResponse{
  int32 id = 1;
  string password = 2;
  string mobile = 3;
  string nickName = 4;
  uint64 birthday = 5;
  string gender = 6;
  int32 role = 7;
}

message UserListResponse{
  int32 total = 1;
  repeated UserInfoResponse data = 2;
}

message CheckResponse{
  bool success = 1;
}
```
生成protobuf go文件
```bash
protoc --go_out=. --go-grpc_out=.  user.proto
```
time.Unix(int64(req.Birthday), 0) 整型转时间戳

4. 启动grpc服务
使用flag进行参数解析
```go
    IP := flag.String("ip", "0.0.0.0", "ip地址")
	Port := flag.Int("port", 50052, "端口号")
	flag.Parse()
```
可以先build 在main.exe后面跟上参数，就可以手动指定ip：port

5. 测试grpc服务
建立grpc客户端 --> 编写测试函数 --> 运行测试函数


## week9 用户web服务
### 第一章 基础项目架构
#### zap 高性能日志库
```text
1.zap有两种日志记录器-Sugared Logger 和 Logger
    Sugared Logger: 方便，比其他日志库快4-10倍 需要用到反射，所以比Logger慢一点
    Logger: 更快，但是使用不这么方便，极致的性能
```

```text
2.zap输出到日志文件
# 自定义日志配置
func NewLogger() (*zap.Logger, error) {
	cfg := zap.NewProductionConfig()
	cfg.OutputPaths = []string{
		"stdout",
		"./myproject.log",
	}
	return cfg.Build()
}

logger, err := NewLogger()
	if err != nil {
		return
	}
	sugar := logger.Sugar()
	defer sugar.Sync()

3.直接拿带锁的全局日志
    zap.S() 返回的其实就是Sugared Logger
        1.S()可以获取一个全局的sugar，可以自己设置一个全局的logger
        2.日志是分级别的，debug，info，warn，error，panic，fatal
        3.S函数和L函数很有用，可以提供一个全局的安全访问logger的途径

```

```text
3.将grpc的错误码转换成http的错误码，返回给用户
func HandleGrpcErrorToHttp(err error, ctx *gin.Context) {
	// 将grpc的状态码转换成http的状态码
	if err != nil {
		if e, ok := status.FromError(err); ok {
			switch e.Code() {
			case codes.NotFound:
				ctx.JSON(http.StatusNotFound, gin.H{
					"msg": e.Message(),
				})
			case codes.Internal:
				ctx.JSON(http.StatusInternalServerError, gin.H{
					"msg": "内部错误",
				})
			case codes.InvalidArgument:
				ctx.JSON(http.StatusBadRequest, gin.H{
					"msg": "参数错误",
				})
			case codes.Unavailable:
				ctx.JSON(http.StatusInternalServerError, gin.H{
					"msg": "服务不可用",
				})
			default:
				ctx.JSON(http.StatusInternalServerError, gin.H{
					"msg": "其他错误",
				})
			}
			return
		}
	}

}
```

```text
4.gin集成viper
建立配置文件yaml --> 创建配置文件结构体 --> 创建全局变量保存配置 --> 创建配置文件初始化并读取函数 --> 在main中使用配置变量
```

### 第二章 用户接口开发
#### 表单验证初始化
```text
1.初始化验证器的翻译功能
func InitTrans(locale string) (err error) {
	//修改gin框架中的validator引擎属性, 实现定制
	if v, ok := binding.Validator.Engine().(*validator.Validate); ok {
		//注册一个获取json的tag的自定义方法
		v.RegisterTagNameFunc(func(fld reflect.StructField) string {
			name := strings.SplitN(fld.Tag.Get("json"), ",", 2)[0]
			if name == "-" {
				return ""
			}
			return name
		})

		zhT := zh.New() //中文翻译器
		enT := en.New() //英文翻译器
		//第一个参数是备用的语言环境，后面的参数是应该支持的语言环境
		uni := ut.New(enT, zhT, enT)
		global.Trans, ok = uni.GetTranslator(locale)
		if !ok {
			return fmt.Errorf("uni.GetTranslator(%s)", locale)
		}

		switch locale {
		case "en":
			en_translations.RegisterDefaultTranslations(v, global.Trans)
		case "zh":
			zh_translations.RegisterDefaultTranslations(v, global.Trans)
		default:
			en_translations.RegisterDefaultTranslations(v, global.Trans)
		}
		return
	}

	return
}
2.处理密码登录的验证流程
func PassWordLogin(ctx *gin.Context) {
    passWordLoginForm := forms.PassWordLoginForm{}
    if err := ctx.ShouldBind(&passWordLoginForm); err != nil {
        errors, ok := err.(validator.ValidationErrors)
        if !ok {
            ctx.JSON(http.StatusOK, gin.H{
                "msg": err.Error(),
            })
        }
        ctx.JSON(http.StatusBadRequest, gin.H{
            "error": removeTopStruct(errors.Translate(global.Trans)),
        })
    }
}
3.去除错误字段名中的结构体名称前缀
func removeTopStruct(fileds map[string]string) map[string]string {
    rsp := map[string]string{}
    for field, err := range fileds {
        rsp[field[strings.Index(field, ".")+1:]] = err
    }
    return rsp
}

```